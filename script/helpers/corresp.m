function [l,t,di,fi,ri,ci,dj,fj,rj,cj] = corresp(X,nfk) ;%usage:  [lambda,tau,di,fi,ri,ci,dj,fj,rj,cj] = corresp(X,nfact2keep) ;% Plain Correspondence Analysis:  %           X: matrix to analyze%  nfact2keep: # of factors (def=all)         % lambda is the eigenvalue vector,% tau is the percentage of inertia vector%  ***  The following matrices represent the rows -> ending i ***% fi is the matrix of the row-coordinates% di is the vector of the (Chi-squared) distance to the centroid% ri is the matrix of the Correlation between the i set and the axis% ci is the matrix of the Contributions%  ***  The following matrices represent the columns -> ending j ***% fj is the matrix of the column-coordinates% dj is the vector of the (Chi-squared) distance to the centroid% rj is the matrix of the Correlation between the j set and the axis% cj is the matrix of the Contributions%%%    Hervé Abdi April 1998 / Revised October 2009 %  See also mca for multiple correspondence analysis%  Related paper: %  Abdi, H. & Williams, L.J. (2010). Correspondence analysis. %  In N.J. Salkind, D.M., Dougherty, & B. Frey (Eds.):  %  Encyclopedia of Research Design. Thousand Oaks (CA): Sage%  herve@utdallas.edu      www.utdallas.edu/~herve%% Compute CA as a bilinear model   le_flip=0; [I,J]=size(X); if J<I; X=X';le_flip=1;[I,J]=size(X);end if exist('nfk') ~=1;nfk=I;end xtot=sum(sum(X)'); xpj=sum(X); xip=sum(X,2); c=sum(X)/xtot; m=sum(X')/xtot; w=ones(1,J) ./ c ; Y= (X./(xip*ones(1,J)))-ones(I,1)*c; %% use an eigenvalue decomposition to save memory %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[P,l]=eigen(((Y.*repmat(w,I,1))*Y').*( (m.^(1/2)')*(m.^(1/2)) ) ); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% nf=length(l);all_l=l; if nf > nfk;nf=nfk;     P=P(:,1:nf);l=l(1:nf); end P= repmat((m'.^(-1/2)),1,nf).*P; d=l.^(1/2); fi=P.*repmat(d',I,1); t=(l/sum(all_l))*100; di=(Y.^2)*w'; ri=repmat((1./di),1,nf ).*( fi.^2); ci=repmat(m',1,nf).*(fi.^2)./repmat(l',I,1);% Compute the solution for the J set using the transition formula  Z=(X./repmat(xpj,I,1)  )';  fj=Z*P;  dj=( (Z-repmat(m,J,1)).^2)*(ones(1,I)./m)';  rj=repmat((1./dj),1,nf ).*( fj.^2);  cj=repmat(c',1,nf).*(fj.^2)./repmat(l',J,1);%%unflipif le_flip==1;    tm=fi;fi=fj;fj=tm;    tm=di;di=dj;dj=tm;    tm=ri;ri=rj;rj=tm;    tm=ci;ci=cj;cj=tm;end    %%%%%%%%%%%%%%% private functions here%%%%%%%%%%%%%%% Eigen function [U,l] = eigen(X);% usage: [U,l]=eigen(X)% Compute the Eigenvalues and Eigenvectors of a% semi positive definite matrix X.% U is the matrix of the eigenvectors.% l is the vector of the eigenvalues.% Eigenvectors & eigenvalues are sorted in decreasing order.% The eigenvectors are normalized: U'* U = I.% Eigenvalues smaller than epsilon=.000001 and% negative eigenvalues (due to rounding errors) are set to zero.% Herve' Abdi, September 1990.    epsilon=eps;%  tolerance to be considered 0 for an eigenvalue   [U,D]=eig(X);   D=diag(D);   [l,k]=sort(D);   n=length(k);    l=l((n+1)-(1:n));    U=U(:,k((n+1)-(1:n)));% keep the non-zero eigen value only (tolerance=epsilon)  pos=find(any([l';l'] > epsilon ));  l=l(pos);  U=U(1:n,pos);% Normalize U -> not needed any more post matlab 6%  U=U./( ones(n,1) * sqrt(sum(U.^2) ) )  ;